namespace cuMat {

/** \page TutorialExpressionTemplates Quick Introduction to Expression Templates

cuMat uses expression templates to combine and optimize chains of operations.
This means, an operation like \code{.cpp} m = (m1 + 2*m2 - m3.cwiseSin()).transpose() \endcode
is evaluated as a single loop, threaded over the available CUDA-cores:
\code{.cpp} 
for (Index_t row=0; row<numRows; ++row) {
    for (Index_t column=0; column<numColumns; ++column) {
        m(column, row) = m1(row, column) + 2*m2(row, column) - sin(m3(row, column))
    }
}
\endcode
Note that no intermediate storage is needed for the addition of the matrices, scaling, component-wise sine and transposition.
Everything is computed on the fly within one kernel execution.

\section TutorialExpressionTemplates_WhatAreThey What are expression templates?

Expression Templates are a meta-programming technique in C++ in which every expression does not evaluate the arguments directly, 
but rather returns an expression on how to lazily evaluate it later.
Example:
\code{.cpp}
MatrixXf m1;
auto expr1 = 2.0f * m1;
\endcode
The type of \c expr1 is \c cuMat::BinaryOp<cuMat::NullaryOp<float, 1, 1, 1, 0, cuMat::ConstantFunctor<float>>,cuMat::Matrix<float,-1,-1,-1,0,>,cuMat::BinaryMathFunctor_cwiseMul<float>,false> .
In form of a tree, the meaning of the template parameters is as follows:
 - \c cuMat::BinaryOp : the root is a binary operation
   - \c cuMat::NullaryOp<float, 1, 1, 1, 0, cuMat::ConstantFunctor<float>> : the first operand of the binary operation, a nullary operation
     - datatype is \c float
     - size is 1, 1, 1 on compile-time (a scalar)
     - storage order is Row-Wise (0), does not really matter
     - the value of the nullary operation is generated by a \c cuMat::ConstantFunctor<float> that stores the parameter \c 2.0f
   - \c cuMat::Matrix<float,-1,-1,-1,0,> : the second operand of the binary operation. This is directly the type of the matrix \c m1
   - \c cuMat::BinaryMathFunctor_cwiseMul<float> : what operation should be executed. In this case, it is a component-wise multiplication
   - the last parameter is an internal detail to support also comparison operations with the same class

The use of expression templates has one major limitation.
It is impossible to build expression trees in a loop with the same variable.
For example, the following code is invalid:
\code{.cpp}
auto expr1 = 2.0f * m1;
expr1 = expr1 + m2;
expr1 = expr1 + m3;
\endcode
This is because the expression tree is encoded in the type of the variable. The type is fixed on the first use of the \c auto keyword and can't change afterwards.
You have to change the code into the following:
\code{.cpp}
auto expr1 = 2.0f * m1;
auto expr2 = expr1 + m2;
auto expr3 = expr2 + m3;
\endcode

\section TutorialExpressionTemplates_Evaluation When are expressions evaluated?

Up to now, no evaluation took place.
The two major ways to evaluate an expression are:
 - Assign the expression to a \c cuMat::Matrix or any other storage (like \c cuMat::MatrixBlock)
 - Force the evaluation by calling \c MatrixBase::eval()

Example:
\code{.cpp}
MatrixXf m1;
auto expr1 = 2.0f * m1; //no evaluation
MatrixXf m2 = expr1; //evaluation
MatrixXf m3 = 2.0f * m1; //same as above in one line
auto m4 = expr1.eval(); //evaluates into a matrix with the optimal storage layout
\endcode
\c .eval() is a bit special: It can be called anywhere within one expression and chooses the optimal storage layout.
Optimality means in this case the least amount of transpose operations and best memory access pattern. Further, if any information about compile-time sizes can be inferred, \c .eval() preserves those.

Some operations directly evaluate the inputs, output or both on creation. This is needed for some computatio intense operations that work directly on the dense matrices. Examples:
 - Reductions evalute the output
 - Matrix-Matrix multiplication first evalute the inputs to matrices and also directly evaluate the output.
 
These special cases are documented with the description of the operations.

*/

}